data.dir <- file.path(my_repo, 'data')
data_extract_EHDv1 <- 'ehd_data_v1.xlsx' #TODO rename
data_extract_EHDv2 <- 'ehd_data_v3.xlsx' #TODO rename
###Output###
out.dir <- file.path(main.dir, 'output')
viz.dir  <- file.path(main.dir, 'viz')
vizdata.dir  <- file.path(my_repo, 'code/baldR/data')
#***********************************************************************************************************************
# ---FUNCTIONS----------------------------------------------------------------------------------------------------------
#source custom functions that are relevant to this module
file.path(code.dir, '_lib', 'prep_fx.R') %>% source
file.path(code.dir, '_lib', 'viz_fx.R') %>% source
##custom utilities##
#helper function to copy things out of R
writeExcel <- function(x,row.names=FALSE,col.names=TRUE,...) {
write.table(x,"clipboard",sep="\t",row.names=row.names,col.names=col.names,...)
}
#label outliers statistically
isOutlier <- function(x) {
quantile(x, 0.25, na.rm=T) - 1.5 * IQR(x, na.rm=T) | x > quantile(x, 0.75, na.rm=T) + 1.5 * IQR(x, na.rm=T)
}
#***********************************************************************************************************************
# ---PREP DATA----------------------------------------------------------------------------------------------------------
##read in and prep datasets for analysis##
if(reload) {
#names of themes have changed, make a map
item_map <- file.path(data.dir, 'ehd_map_theme_names.csv') %>% fread
#life expectancy data
le_dt <-  file.path(data.dir, 'le_at_birth_2015_2019.csv') %>% fread
setnames(le_dt, names(le_dt),
c('county', 'geocode', 'le', 'lower', 'upper'))
le_dt[, c('le', 'lower', 'upper') := lapply(.SD, as.numeric), .SDcols=c('le', 'lower', 'upper')]
#also bring in the census tracts shapefile in order to do some cartography
#can be downloaded from the census website using tigris
tract_sf <- tracts('WA', year=2010, cb=T) %>%
st_transform(32148) %>%
erase_water(area_threshold = 0.9) %>% #intersect with water overlay and remove
mutate('GEOID'=substring(GEO_ID, 10)) #remove the excess first 9 chr and rename GEOID
#use the water shapefile as an overlay
counties_list <- counties('WA', cb=T)
water_sf <- area_water('WA', counties_list$COUNTYFP %>% unique) %>%
st_simplify(preserveTopology = TRUE, dTolerance = 100)
#also overlay roads
road_sf <- primary_secondary_roads(state='WA') %>%
st_simplify(preserveTopology = TRUE, dTolerance = 100)
#also overlay places
places_sf <- places(state = 'WA', cb = T)
#first read in and calculate all the ranks using custom function
ranks_old <- rankeR(dir=data.dir, path=data_extract_EHDv1, clean_names=item_map, debug=F)
ranks_new <- rankeR(dir=data.dir, path=data_extract_EHDv2, debug=T)
##create comparisons##
#merge measures (old v. new) to compare
measure_ranks <- merge(ranks_old$measure[, .(GEOID, item, item_short, theme, level,
rank_v1=measure_rank_integer)],
ranks_new$measure[, .(GEOID, item, theme, level,
rank=measure_rank_integer),],
by=c('GEOID', 'item', 'theme', 'level'), all = T) %>%
.[, rank_shift := rank-rank_v1] %>%
.[, rank_shift_capped := rank_shift] %>%
.[rank_shift>=5, rank_shift_capped := 5] %>% #cap shift to max for plotting
.[rank_shift<=-5, rank_shift_capped := -5]  %>%
.[, rank_shift := rank_shift_capped] %>%
.[, rank_shift_capped := NULL]
#merge raw measures (old v. new) to compare
measure_raw <- merge(ranks_old$measure_raw[, .(GEOID, item, item_short, theme, level,
measure_v1=measure_rank_val)],
ranks_new$measure[, .(GEOID, item, theme, level,
measure=measure_rank_val)],
by=c('GEOID', 'item', 'theme', 'level'), all=T) %>%
.[, measure_shift := measure-measure_v1] %>%
.[, measure_ratio := measure/measure_v1] %>%
.[measure_ratio %>% is.infinite, measure_ratio := NA] #0s create issues here
#merge both measures datasets
measure_dt <- merge(measure_ranks,
measure_raw[, .(GEOID, item, measure, measure_v1, measure_shift, measure_ratio)],
by=c('GEOID', 'item'))
#merge themes
theme_dt <- merge(ranks_old$theme[, .(GEOID, item, item_short, theme, level,
rank_v1=theme_rank_integer)],
ranks_new$theme[, .(GEOID, item, theme, level,
rank=theme_rank_integer)],
by=c('GEOID', 'item', 'theme', 'level')) %>%
.[, rank_shift := rank-rank_v1] %>%
.[, rank_shift_capped := rank_shift] %>%
.[rank_shift>=5, rank_shift_capped := 5] %>% #cap shift to max for plotting
.[rank_shift<=-5, rank_shift_capped := -5]  %>%
.[, rank_shift := rank_shift_capped] %>%
.[, rank_shift_capped := NULL]
#merge indexes (old v. new) to compare
index_dt <- merge(ranks_old$index[, .(GEOID, item, item_short, theme, level,
rank_v1=index_rank_integer)],
ranks_new$index[, .(GEOID, item, theme, level,
rank=index_rank_integer)],
by=c('GEOID', 'item', 'theme', 'level')) %>%
.[, rank_shift := rank-rank_v1] %>%
.[, rank_shift_capped := rank_shift] %>%
.[rank_shift>=5, rank_shift_capped := 5] %>% #cap shift to max for plotting
.[rank_shift<=-5, rank_shift_capped := -5]  %>%
.[, rank_shift := rank_shift_capped] %>%
.[, rank_shift_capped := NULL]
##post estimations##
#identify dropout units based on impacted threshold of >8
threshold_val <- 9
index_dt[, impacted := 0]
index_dt[, impacted_v1 := 0]
index_dt[rank>=threshold_val, impacted := 1]
index_dt[rank_v1>=threshold_val, impacted_v1 := 1]
index_dt[, dropout := factor(impacted_v1 - impacted,
levels=c(-1, 0, 1),
labels=c('Addition',
'Steady',
'Dropout'))]
#add life expectancy data
index_dt <- merge(index_dt, le_dt, by.x='GEOID', by.y='geocode')
index_dt[, le_state_average := mean(le, na.rm=T)]
index_dt[, life_expectancy := paste0(le, ' years (', lower, '-', upper, ')')]
#merge the dropouts back onto the other tables for graphing
measure_dt <- merge(measure_dt, index_dt[, .(GEOID, dropout, index=rank,
impacted, impacted_v1, life_expectancy)], by='GEOID')
theme_dt <- merge(theme_dt, index_dt[, .(GEOID, dropout, index=rank,
impacted, impacted_v1, life_expectancy)], by='GEOID')
#label the outliers
#index_dt[, outlier_lab := ifelse(isOutlier(le), name, NA_character_), by=index_new]
##output##
#save all data
out <- list(
'index'=index_dt,
'ranks'=measure_ranks,
'ranks_new'=ranks_new,
'ranks_old'=ranks_old,
'measures'=measure_raw,
'themes'=theme_dt,
'tracts'=tract_sf,
'water'=water_sf
)
save(out, file=file.path(out.dir, 'all_data.RData'))
#reformat the data long to simplify for the mapping tool
#TODO - eventually i think it makes sense to adapt all future code to use this long version
dt <- list(index_dt[, -c('le', 'lower', 'upper', 'le_state_average', 'county'), with=F],
theme_dt,
measure_dt) %>%
rbindlist(use.names=T, fill=T)
dt[item=='Aggregated', item_short := 'Agg'] #TODO fix earlier
dt <- dt[!(is.na(item_short))] #rows that didn't have data for v1
#make it possible to use a logged scale on measure, which tends skewed
#dt[, measure_trans := log(measure + 0.001)]
#dt[item %like% '%' & measure>0, measure_trans := car::logit(measure+0.001)]
#dt[, measure_v1_trans := log(measure_v1 + 0.001)]
#dt[item %like% '%' & measure_v1>0, measure_v1_trans := car::logit(measure_v1+0.001)]
#save a  version of the data for the online mapping tool
out <- list(
'dt'=dt,
'tract_sf'=tract_sf,
'water_sf'=water_sf,
'road_sf'=road_sf,
'places_sf'=places_sf
)
saveRDS(out, file=file.path(vizdata.dir, 'viz_data.RDS'))
#also save a csv of the lite data for edmund
out <- list(
'dt'=dt,
'tracts'=tract_sf
)
saveRDS(out, file=file.path(out.dir, 'lite_data.RDS'))
write.csv(dt, file=file.path(out.dir, 'lite_data.csv'))
} else file.path(vizdata.dir, 'viz_data.RDS') %>% readRDS %>% list2env(., globalenv())
head(dt[level==1])
# ---ANALYZE------------------------------------------------------------------------------------------------------------
##variable importance investigation##
#simulation analysis#
#first read in and calculate all the ranks using custom function
ranks_per <- lapply(unique(dt$item)[-1] %>% as.character,
rankeR,
dir=data.dir,
path=data_extract_EHDv2,
nranks=10,
clean_names=F) %>%
rbindlist %>%
.[, .(GEOID, permute_rank=index_rank_integer, permutation)]
head(ranks_per)
ranks_per <- merge(ranks_per,
dt[level==1],
by='GEOID',
allow.cartesian=T)
head(ranks_per)
rank_uncertainty <- ranks_per[, range:=max(permute_rank)-min(permute_rank, by=GEOID)]
rank_uncertainty <- ranks_per[, range:=max(permute_rank)-min(permute_rank), by=GEOID)]
rank_uncertainty <- ranks_per[, range:=max(permute_rank)-min(permute_rank), by=GEOID]
rank_uncertainty
head(rank_uncertainty)
rank_uncertainty <- ranks_per[, range:=max(permute_rank)-min(permute_rank), by=GEOID] %>%
unique(by='GEOID')
head(rank_uncertainty)
summary(ranks_per$range)
cartographeR(dt=rank_uncertainty, map_varname = 'range', map_label = 'Range in Ranking',
map_title = 'Rank Range', scale_type='cont_man', scale_vals = cont_colors)
o
o
# ---MAP----------------------------------------------------------------------------------------------------------------
#create a manual diverging color scale to make sure that the index shifts are uniformly depicted
div_colors <- RColorBrewer::brewer.pal(11, 'RdBu') %>% rev
names(div_colors) <- dt[, unique(rank_shift) %>% sort]
#create a manual discrete color scale for the continuous index and make sure the color scale legend has all integers
cont_colors <- viridis::magma(n = 10)
names(cont_colors) <- 1:10
#drop water codes with weird data from maps
drop_geocodes <- c('53057990100' #san juan water area with lots of big changes
)
cartographeR(dt=rank_uncertainty, map_varname = 'range', map_label = 'Range in Ranking',
map_title = 'Rank Range', scale_type='cont_man', scale_vals = cont_colors)
rank_uncertainty$range %>% class
cartographeR(dt=rank_uncertainty, map_varname = 'range', map_label = 'Range in Ranking',
map_title = 'Rank Range', scale_type='cont')
head(rank_uncertainty)
ggplot(reg_dt, aes(x=rank, range, color=rank_shift %>% as.factor) ) +
geom_point(position='jitter')
ggplot(rank_uncertainty, aes(x=rank, range, color=rank_shift %>% as.factor) ) +
geom_point(position='jitter')
ggplot(rank_uncertainty, aes(x=rank, range, color=rank_shift %>% as.factor) ) +
geom_point(position='jitter') +
scale_color_viridis_d('Change in Rank') +
theme_bw()
file.path(viz.dir, 'rank_range_scatters.png') %>% ggsave(height=8, width=12)
head(ranks_per)
threshold_val <- 9
ranks_per[, permute_impacted := 0]
ranks_per[permute_rank>=threshold_val, permute_impacted := 1]
head(ranks_per)
impacted_uncertainty <- ranks_per[, (impacted==permute_impacted)/.N, by=GEOID] %>%
unique(by='GEOID')
rank_uncertainty <- ranks_per[, range:=max(permute_rank)-min(permute_rank), by=GEOID] %>%
.[, impacted_acc := (impacted==permute_impacted)/.N, by=GEOID] %>%
unique(by='GEOID')
head(rank_uncertainty)
rank_uncertainty <- ranks_per[, range:=max(permute_rank)-min(permute_rank), by=GEOID] %>%
.[, impacted_acc := sum(impacted==permute_impacted)/.N, by=GEOID] %>%
unique(by='GEOID')
head(rank_uncertainty)
summary(rank_uncertainty$impacted_acc)
cartographeR(dt=rank_uncertainty, map_varname = 'impacted_acc', map_label = 'Accuracy',
map_title = 'Accuracy of Impacted Classification', scale_type='cont')
rank_uncertainty <- ranks_per[, range:=max(permute_rank)-min(permute_rank), by=GEOID] %>%
.[, rank_acc := sum(permute_rank==rank)/.N, by=GEOID] %>%
.[, impacted_acc := sum(impacted==permute_impacted)/.N, by=GEOID] %>%
unique(by='GEOID')
cartographeR(dt=rank_uncertainty, map_varname = 'rank_acc', map_label = 'Accuracy',
map_title = 'Accuracy of Ranking', scale_type='cont')
ggplot(rank_uncertainty, aes(x=rank, rank_acc, color=rank_shift %>% as.factor) ) +
geom_point(position='jitter') +
scale_color_viridis_d('Change in Rank') +
theme_bw()
file.path(viz.dir, 'rank_acc_scatters.png') %>% ggsave(height=8, width=12)
var_imp <- ranks_per[, importance := mean(permute_rank-rank), by=permutation] %>%
unique(by='permutation')
head(var_imp)
summary(var_imp$importance)
ranks_per[, permute_shift := permute_rank-rank]
ggplot(ranks_per, aes(x=permute_shift, y=forcats::fct_reorder(permutation, permute_shift, .fun=mean),
fill = stat(x))) +
stat_density_ridges(geom = "density_ridges_gradient", calc_ecdf = TRUE) +
scale_fill_viridis_c(name = "Index Ranking Change", direction = -1, option='plasma') +
scale_y_discrete('Permuted Item') +
theme_bw()
file.path(viz.dir, 'rank_importance_ridges.png') %>% ggsave(height=8, width=12)
ggplot(ranks_per, aes(x=permute_shift, y=forcats::fct_reorder(permutation, permute_shift, .fun=mean),
fill = stat(x))) +
stat_density_ridges(stat='binline') +
scale_fill_viridis_c(name = "Index Ranking Change", direction = -1, option='plasma') +
scale_y_discrete('Permuted Item') +
theme_bw()
ggplot(ranks_per, aes(x=permute_shift, y=forcats::fct_reorder(permutation, permute_shift, .fun=mean),
fill = stat(x))) +
geom_density_ridges(stat='binline') +
scale_fill_viridis_c(name = "Index Ranking Change", direction = -1, option='plasma') +
scale_y_discrete('Permuted Item') +
theme_bw()
head(ranks_per)
ggplot(ranks_per, aes(x=permute_shift, y=forcats::fct_reorder(permutation, permute_shift, .fun=mean),
)) +
geom_density_ridges(stat='binline') +
scale_fill_viridis_c(name = "Index Ranking Change", direction = -1, option='plasma') +
scale_y_discrete('Permuted Item') +
theme_bw()
file.path(viz.dir, 'rank_importance_ridges.png') %>% ggsave(height=8, width=12)
var_imp <- ranks_per[, importance_mean := mean(permute_rank-rank), by=permutation] %>%
.[, importance_max := max(abs(permute_rank-rank)), by=permutation] %>%
unique(by='permutation')
ggplot(var_imp, aes(x=permutation, y=importance_max)) +
geom_point() +
geom_segment( aes(x=permutation, xend=permutation, y=0, yend=importance_max))
ggplot(var_imp, aes(x=permutation, y=importance_max)) +
geom_point() +
geom_segment( aes(x=permutation, xend=permutation, y=0, yend=importance_max)) +
theme_bw() +
coord_flip()
file.path(viz.dir, 'rank_importance_lolli.png') %>% ggsave(height=8, width=12)
ggplot(var_imp, aes(x=forcats::fct_reorder(permutation, importance_max),
y=importance_max)) +
geom_point() +
geom_segment( aes(x=permutation, xend=permutation, y=0, yend=importance_max)) +
theme_bw() +
coord_flip()
file.path(viz.dir, 'rank_importance_lolli.png') %>% ggsave(height=8, width=12)
dt[level==2, .(item, theme)] %>% unique(by='item')
dt[level==3, .(item, theme)] %>% unique(by='item')
ranks_per <- merge(ranks_per,
dt[level==2, .(item, theme)] %>% unique(by='item'),
by.x='permutation',
by.y = 'item')
head(ranks_per)
ranks_per <- lapply(unique(dt$item)[-1] %>% as.character,
rankeR,
dir=data.dir,
path=data_extract_EHDv2,
nranks=10,
clean_names=F) %>%
rbindlist %>%
.[, .(GEOID, permute_rank=index_rank_integer, permutation)]
ranks_per <- merge(ranks_per,
dt[level==1],
by='GEOID',
allow.cartesian=T)
ranks_per <- merge(ranks_per,
dt[level==3],
by='GEOID',
allow.cartesian=T)
head(ranks_per)
ranks_per <- lapply(unique(dt$item)[-1] %>% as.character,
rankeR,
dir=data.dir,
path=data_extract_EHDv2,
nranks=10,
clean_names=F) %>%
rbindlist %>%
.[, .(GEOID, permute_rank=index_rank_integer, permutation)]
ranks_per <- merge(ranks_per[, theme:=NULL],
dt[level==3],
by='GEOID',
allow.cartesian=T)
head(ranks_per)
ranks_per <- lapply(unique(dt$item)[-1] %>% as.character,
rankeR,
dir=data.dir,
path=data_extract_EHDv2,
nranks=10,
clean_names=F) %>%
rbindlist %>%
.[, .(GEOID, permute_rank=index_rank_integer, permutation)]
ranks_per <- merge(ranks_per,
dt[level==1],
by='GEOID',
allow.cartesian=T)
tmp <- merge(ranks_per[, `:=`(item = NULL, them = NULL)],
dt[level==3, .(item, theme)] %>% unique(by='item'),
by.x='permutation',
by.y = 'item')
head(tmp)
tmp <- merge(ranks_per[, `:=`(item = NULL, theme = NULL)],
dt[level==3, .(item, theme)] %>% unique(by='item'),
by.x='permutation',
by.y = 'item')
head(tmp)
ranks_per <- merge(ranks_per[, `:=`(item = NULL, theme = NULL)],
dt[level==3, .(item, theme)] %>% unique(by='item'),
by.x='permutation',
by.y = 'item')
head(ranks_per)
ggplot(var_imp, aes(x=forcats::fct_reorder(permutation, importance_max),
y=importance_max,
color=theme)) +
geom_point() +
geom_segment( aes(x=permutation, xend=permutation, y=0, yend=importance_max)) +
theme_bw() +
coord_flip()
ggplot(var_imp, aes(x=forcats::fct_reorder(permutation, importance_max),
y=importance_max,
color=theme)) +
geom_point() +
geom_segment( aes(x=permutation, xend=permutation, y=0, yend=importance_max)) +
theme_bw() +
scale_color_brewer('Theme', palette='Paired') +
coord_flip()
file.path(viz.dir, 'rank_importance_lolli.png') %>% ggsave(height=8, width=12)
var_imp <- ranks_per[, importance_mean := mean(permute_rank-rank), by=permutation] %>%
.[, importance_max := max(abs(permute_rank-rank)), by=permutation] %>%
unique(by='permutation')
ggplot(var_imp, aes(x=forcats::fct_reorder(permutation, importance_max),
y=importance_max,
color=theme)) +
geom_point() +
geom_segment( aes(x=permutation, xend=permutation, y=0, yend=importance_max)) +
theme_bw() +
scale_color_brewer('Theme', palette='Paired') +
coord_flip()
file.path(viz.dir, 'rank_importance_lolli.png') %>% ggsave(height=8, width=12)
var_imp <- ranks_per[, importance_mean := mean(permute_rank-rank), by=permutation] %>%
.[, importance_max := max(abs(permute_rank-rank)), by=permutation] %>%
.[, importance_max := mean((permute_rank-rank)/rank), by=permutation] %>%
unique(by='permutation')
ggplot(var_imp, aes(x=forcats::fct_reorder(permutation, importance_max),
y=importance_max,
color=theme)) +
geom_point() +
geom_segment( aes(x=permutation, xend=permutation, y=0, yend=importance_max)) +
theme_bw() +
scale_color_brewer('Theme', palette='Paired') +
coord_flip()
file.path(viz.dir, 'rank_importance_max_lolli.png') %>% ggsave(height=8, width=12)
var_imp <- ranks_per[, importance_mean := mean(permute_rank-rank), by=permutation] %>%
.[, importance_max := max(abs(permute_rank-rank)), by=permutation] %>%
.[, importance_mean := mean(abs(permute_rank-rank)), by=permutation] %>%
unique(by='permutation')
ggplot(var_imp, aes(x=forcats::fct_reorder(permutation, importance_max),
y=importance_max,
color=theme)) +
geom_point() +
geom_segment( aes(x=permutation, xend=permutation, y=0, yend=importance_max)) +
theme_bw() +
scale_color_brewer('Theme', palette='Paired') +
coord_flip()
file.path(viz.dir, 'rank_importance_max_lolli.png') %>% ggsave(height=8, width=12)
ggplot(var_imp, aes(x=forcats::fct_reorder(permutation, importance_mean),
y=importance_max,
color=theme)) +
geom_point() +
geom_segment( aes(x=permutation, xend=permutation, y=0, yend=importance_mean)) +
theme_bw() +
scale_color_brewer('Theme', palette='Paired') +
coord_flip()
file.path(viz.dir, 'rank_importance_mean_lolli.png') %>% ggsave(height=8, width=12)
ggplot(var_imp, aes(x=forcats::fct_reorder(permutation, importance_mean),
y=importance_mean,
color=theme)) +
geom_point() +
geom_segment( aes(x=permutation, xend=permutation, y=0, yend=importance_mean)) +
theme_bw() +
scale_color_brewer('Theme', palette='Paired') +
coord_flip()
file.path(viz.dir, 'rank_importance_mean_lolli.png') %>% ggsave(height=8, width=12)
var_imp <- ranks_per[, importance_mean := mean(permute_rank-rank), by=permutation] %>%
.[, importance_max := max(abs(permute_rank-rank)), by=permutation] %>%
.[, importance_mean := mean(abs(permute_rank-rank)), by=permutation] %>%
.[, importance_acc :=sum(impacted==permute_impacted)/.N] %>%
unique(by='permutation')
head(ranks_per)
#identify dropout units based on impacted threshold of >8
threshold_val <- 9
ranks_per[, permute_impacted := 0]
ranks_per[permute_rank>=threshold_val, permute_impacted := 1]
ranks_per[, permute_shift := permute_rank-rank]
var_imp <- ranks_per[, importance_mean := mean(permute_rank-rank), by=permutation] %>%
.[, importance_max := max(abs(permute_rank-rank)), by=permutation] %>%
.[, importance_mean := mean(abs(permute_rank-rank)), by=permutation] %>%
.[, importance_acc :=sum(impacted==permute_impacted)/.N] %>%
unique(by='permutation')
ggplot(var_imp, aes(x=forcats::fct_reorder(permutation, importance_acc),
y=importance_acc,
color=theme)) +
geom_point() +
geom_segment( aes(x=permutation, xend=permutation, y=0, yend=importance_acc)) +
theme_bw() +
scale_color_brewer('Theme', palette='Paired') +
coord_flip()
file.path(viz.dir, 'rank_importance_acc_lolli.png') %>% ggsave(height=8, width=12)
var_imp <- ranks_per[, importance_mean := mean(permute_rank-rank), by=permutation] %>%
.[, importance_max := max(abs(permute_rank-rank)), by=permutation] %>%
.[, importance_mean := mean(abs(permute_rank-rank)), by=permutation] %>%
.[, importance_acc :=sum(impacted==permute_impacted)/.N, by=permutation] %>%
unique(by='permutation')
ggplot(var_imp, aes(x=forcats::fct_reorder(permutation, importance_acc),
y=importance_acc,
color=theme)) +
geom_point() +
geom_segment( aes(x=permutation, xend=permutation, y=0, yend=importance_acc)) +
theme_bw() +
scale_color_brewer('Theme', palette='Paired') +
coord_flip()
file.path(viz.dir, 'rank_importance_acc_lolli.png') %>% ggsave(height=8, width=12)
head(var_imp)
ggplot(var_imp, aes(x=forcats::fct_reorder(permutation, importance_acc),
y=importance_acc,
color=theme)) +
geom_point() +
geom_segment( aes(x=permutation, xend=permutation, y=0, yend=importance_acc)) +
theme_bw() +
scale_color_brewer('Theme', palette='Paired') +
coord_flip()
file.path(viz.dir, 'rank_importance_acc_lolli.png') %>% ggsave(height=8, width=12)
ggplot(var_imp, aes(x=forcats::fct_reorder(permutation, importance_acc),
y=importance_acc,
color=theme)) +
geom_point() +
geom_segment( aes(x=permutation, xend=permutation, y=0, yend=importance_acc)) +
theme_bw() +
scale_color_brewer('Theme', palette='Paired') +
coord_flip()
file.path(viz.dir, 'rank_importance_acc_lolli.png') %>% ggsave(height=8, width=12)
file.path(viz.dir, 'rank_importance_acc_lolli.png') %>% ggsave(height=8, width=12)
var_imp <- ranks_per[, importance_mean := mean(permute_rank-rank), by=permutation] %>%
.[, importance_max := max(abs(permute_rank-rank)), by=permutation] %>%
.[, importance_mean := mean(abs(permute_rank-rank)), by=permutation] %>%
.[, importance_acc :=sum(impacted==permute_impacted)/.N, by=permutation] %>%
unique(by='permutation')
ggplot(var_imp, aes(x=forcats::fct_reorder(permutation, importance_acc),
y=importance_acc,
color=theme)) +
geom_point() +
geom_segment( aes(x=permutation, xend=permutation, y=0, yend=importance_acc)) +
theme_bw() +
scale_color_brewer('Theme', palette='Paired') +
coord_flip()
file.path(viz.dir, 'rank_importance_acc_lolli.png') %>% ggsave(height=8, width=12)
